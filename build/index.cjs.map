{
  "version": 3,
  "sources": ["../src/index.ts", "../src/parse.ts", "../src/stringify.ts"],
  "sourcesContent": ["export { parse } from './parse.js'\nexport { stringify } from './stringify.js'\n", "export function parse(source: string): any {\n  if (typeof source !== 'string') throw TypeError('Source must be a string')\n\n  let pos = 0,\n    lineNumber = 1,\n    ch: string,\n    done = false\n\n  next()\n  const value = parseValue()\n  skipWhitespace()\n\n  if (!done) {\n    throw new SyntaxError(errorSnippet())\n  }\n\n  expectValue(value)\n  return value\n\n  function next() {\n    if (pos < source.length) {\n      ch = source[pos]\n      pos++\n    } else {\n      ch = ''\n      done = true\n    }\n    if (ch === '\\n') {\n      lineNumber++\n    }\n  }\n\n  function lookahead2() {\n    return source.substring(pos, pos + 2)\n  }\n\n  function parseValue(): any {\n    skipWhitespace()\n    return (\n      parseMultilineString() ??\n      parseString() ??\n      parseNumber() ??\n      parseObject() ??\n      parseArray() ??\n      parseKeyword('true', true) ??\n      parseKeyword('false', false) ??\n      parseKeyword('null', null)\n    )\n  }\n\n  function parseString() {\n    if (ch !== '\"') return\n    let str = ''\n    let escaped = false\n    while (true) {\n      next()\n      if (escaped) {\n        if ((ch as string) === 'u') {\n          next()\n          if ((ch as string) !== '{') {\n            throw new SyntaxError(\n              errorSnippet(\n                errorMap.u + ' ' + JSON.stringify(ch) + ' (expected \"{\")',\n              ),\n            )\n          }\n          let hex = ''\n          while (true) {\n            next()\n            if ((ch as string) === '}') break\n            if (!isHexDigit(ch)) {\n              throw new SyntaxError(\n                errorSnippet(errorMap.u + ' ' + JSON.stringify(ch)),\n              )\n            }\n            hex += ch\n            if (hex.length > 6) {\n              throw new SyntaxError(\n                errorSnippet(errorMap.u + ' (too many hex digits)'),\n              )\n            }\n          }\n          if (hex.length === 0) {\n            throw new SyntaxError(errorSnippet(errorMap.u))\n          }\n          const codePoint = parseInt(hex, 16)\n          if (codePoint > 0x10ffff) {\n            throw new SyntaxError(errorSnippet(errorMap.u + ' (out of range)'))\n          }\n          str += String.fromCodePoint(codePoint)\n        } else {\n          const escapedChar = escapeMap[ch]\n          if (!escapedChar) {\n            throw new SyntaxError(\n              errorSnippet(errorMap.u + ' ' + JSON.stringify(ch)),\n            )\n          }\n          str += escapedChar\n        }\n        escaped = false\n      } else if ((ch as string) === '\\\\') {\n        escaped = true\n      } else if (ch === '\"') {\n        break\n      } else if ((ch as string) === '\\n') {\n        throw new SyntaxError(\n          errorSnippet(\n            `Use \"\"\" for multiline strings or escape newlines with \"\\\\n\"`,\n          ),\n        )\n      } else if ((ch as string) < '\\x1F') {\n        throw new SyntaxError(\n          errorSnippet(`Unescaped control character ${JSON.stringify(ch)}`),\n        )\n      } else {\n        str += ch\n      }\n    }\n    next()\n    return str\n  }\n\n  function parseMultilineString() {\n    if (ch !== '\"' || lookahead2() !== '\"\"') return\n    next()\n    next()\n    next()\n    let hasLeadingNewline = false\n    if ((ch as string) === '\\n') {\n      hasLeadingNewline = true\n      next()\n    }\n\n    let str = ''\n    while (!done) {\n      if (ch === '\"' && lookahead2() === '\"\"') {\n        next()\n        next()\n        next()\n        if (str === '' && !hasLeadingNewline) {\n          throw new SyntaxError(\n            errorSnippet('Multiline strings cannot be empty'),\n          )\n        }\n        return str\n      }\n      str += ch\n      next()\n    }\n    throw new SyntaxError(errorSnippet())\n  }\n\n  function parseNumber() {\n    if (!isDigit(ch) && ch !== '-') return\n    let numStr = ''\n    let float = false\n    if (ch === '-') {\n      numStr += ch\n      next()\n      if (!isDigit(ch)) {\n        throw new SyntaxError(errorSnippet())\n      }\n    }\n    if (ch === '0') {\n      numStr += ch\n      next()\n    } else {\n      while (isDigit(ch)) {\n        numStr += ch\n        next()\n      }\n    }\n    if (ch === '.') {\n      float = true\n      numStr += ch\n      next()\n      if (!isDigit(ch)) {\n        throw new SyntaxError(errorSnippet())\n      }\n      while (isDigit(ch)) {\n        numStr += ch\n        next()\n      }\n    }\n    if (ch === 'e' || ch === 'E') {\n      float = true\n      numStr += ch\n      next()\n      if ((ch as string) === '+' || (ch as string) === '-') {\n        numStr += ch\n        next()\n      }\n      if (!isDigit(ch)) {\n        throw new SyntaxError(errorSnippet())\n      }\n      while (isDigit(ch)) {\n        numStr += ch\n        next()\n      }\n    }\n    return float ? parseFloat(numStr) : toSafeNumber(numStr)\n  }\n\n  function parseObject() {\n    if (ch !== '{') return\n    next()\n    skipWhitespace()\n    const obj: Record<string, any> = {}\n    if ((ch as string) === '}') {\n      next()\n      return obj\n    }\n    while (true) {\n      const keyPos = pos\n      let key: string\n      if ((ch as string) === '\"') {\n        key = parseString()!\n      } else {\n        key = parseKey()\n      }\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        pos = keyPos\n        throw new SyntaxError(\n          errorSnippet(`Duplicate key ${JSON.stringify(key)}`),\n        )\n      }\n      skipWhitespace()\n      if ((ch as string) !== ':') {\n        throw new SyntaxError(errorSnippet())\n      }\n      next()\n      const value = parseValue()\n      expectValue(value)\n      obj[key] = value\n      const newlineAfterValue = skipWhitespace()\n      if ((ch as string) === '}') {\n        next()\n        return obj\n      } else if ((ch as string) === ',') {\n        next()\n        skipWhitespace()\n        if ((ch as string) === '}') {\n          next()\n          return obj\n        }\n      } else if (newlineAfterValue) {\n        continue\n      } else {\n        throw new SyntaxError(\n          errorSnippet('Expected comma or newline between key-value pairs'),\n        )\n      }\n    }\n  }\n\n  function parseKey() {\n    let identifier = ''\n    while (isKeyChar(ch)) {\n      identifier += ch\n      next()\n    }\n    if (identifier === '') {\n      throw new SyntaxError(errorSnippet())\n    }\n    return identifier\n  }\n\n  function parseArray() {\n    if (ch !== '[') return\n    next()\n    skipWhitespace()\n    const array: any[] = []\n    if ((ch as string) === ']') {\n      next()\n      return array\n    }\n    while (true) {\n      const value = parseValue()\n      expectValue(value)\n      array.push(value)\n      const newLineAfterValue = skipWhitespace()\n      if ((ch as string) === ']') {\n        next()\n        return array\n      } else if ((ch as string) === ',') {\n        next()\n        skipWhitespace()\n        if ((ch as string) === ']') {\n          next()\n          return array\n        }\n      } else if (newLineAfterValue) {\n        continue\n      } else {\n        throw new SyntaxError(\n          errorSnippet('Expected comma or newline between values'),\n        )\n      }\n    }\n  }\n\n  function parseKeyword<T>(name: string, value: T) {\n    if (ch !== name[0]) return\n    for (let i = 1; i < name.length; i++) {\n      next()\n      if (ch !== name[i]) {\n        throw new SyntaxError(errorSnippet())\n      }\n    }\n    next()\n    if (\n      isWhitespace(ch) ||\n      ch === ',' ||\n      ch === '}' ||\n      ch === ']' ||\n      ch === undefined\n    ) {\n      return value\n    }\n    throw new SyntaxError(errorSnippet())\n  }\n\n  function skipWhitespace(): boolean {\n    let hasNewline = false\n    while (isWhitespace(ch)) {\n      hasNewline ||= ch === '\\n'\n      next()\n    }\n    const hasNewlineAfterComment = skipComment()\n    return hasNewline || hasNewlineAfterComment\n  }\n\n  function skipComment(): boolean {\n    if (ch === '#') {\n      while (!done && (ch as string) !== '\\n') {\n        next()\n      }\n      return skipWhitespace()\n    }\n    return false\n  }\n\n  function isWhitespace(ch: string) {\n    return ch === ' ' || ch === '\\n' || ch === '\\t' || ch === '\\r'\n  }\n\n  function isHexDigit(ch: string) {\n    return (ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'F')\n  }\n\n  function isDigit(ch: string) {\n    return ch >= '0' && ch <= '9'\n  }\n\n  function isKeyChar(ch: string) {\n    return (\n      (ch >= 'A' && ch <= 'Z') ||\n      (ch >= 'a' && ch <= 'z') ||\n      (ch >= '0' && ch <= '9') ||\n      ch === '_' ||\n      ch === '-'\n    )\n  }\n\n  function toSafeNumber(str: string) {\n    if (str == '-0') return -0\n    const num = Number(str)\n    return num >= Number.MIN_SAFE_INTEGER && num <= Number.MAX_SAFE_INTEGER\n      ? num\n      : BigInt(str)\n  }\n\n  function expectValue(value: unknown) {\n    if (value === undefined) {\n      throw new SyntaxError(errorSnippet())\n    }\n  }\n\n  function errorSnippet(\n    message = `Unexpected character ${JSON.stringify(ch)}`,\n  ) {\n    if (!ch) message = 'Unexpected end of input'\n    const lines = source.substring(pos - 40, pos).split('\\n')\n    let lastLine = lines.at(-1) || ''\n    let postfix =\n      source\n        .substring(pos, pos + 40)\n        .split('\\n', 1)\n        .at(0) || ''\n    if (lastLine === '') {\n      // error at \"\\n\"\n      lastLine = lines.at(-2) || ''\n      lastLine += ' '\n      lineNumber--\n      postfix = ''\n    }\n    const snippet = `    ${lastLine}${postfix}\\n`\n    const pointer = `    ${'.'.repeat(Math.max(0, lastLine.length - 1))}^\\n`\n    return `${message} on line ${lineNumber}.\\n\\n${snippet}${pointer}`\n  }\n}\n\nconst escapeMap: Record<string, string> = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t',\n}\n\nconst errorMap = {\n  u: 'Invalid escape sequence',\n}\n", "export function stringify(value: any): string {\n  return doStringify(value, 0)\n}\n\nfunction doStringify(value: any, level: number): string {\n  const kind =\n    value === null ? 'null' : Array.isArray(value) ? 'array' : typeof value\n\n  switch (kind) {\n    case 'string':\n      return JSON.stringify(value)\n\n    case 'boolean':\n    case 'bigint':\n    case 'number':\n      return `${value}`\n\n    case 'null':\n    case 'undefined':\n      return 'null'\n\n    case 'array': {\n      const len = value.length\n      if (len === 0) return '[]'\n\n      const childIndent = getIndent(level + 1)\n      const parentIndent = getIndent(level)\n      let out = '[\\n'\n      for (let i = 0; i < len; i++) {\n        if (i > 0) out += '\\n'\n        out += childIndent + doStringify(value[i], level + 1)\n      }\n      return out + '\\n' + parentIndent + ']'\n    }\n\n    case 'object': {\n      const keys = Object.keys(value)\n      const len = keys.length\n      if (len === 0) return '{}'\n\n      const childIndent = getIndent(level + 1)\n      const parentIndent = getIndent(level)\n      let out = '{\\n'\n      for (let i = 0; i < len; i++) {\n        if (i > 0) out += '\\n'\n        const key = keys[i]\n        out +=\n          childIndent +\n          doKeyStringify(key) +\n          ': ' +\n          doStringify(value[key], level + 1)\n      }\n      return out + '\\n' + parentIndent + '}'\n    }\n\n    default:\n      throw new Error(`Unsupported value type: ${kind}`)\n  }\n}\n\nconst KEY_RE = /^[A-Za-z0-9_-]+$/\nfunction doKeyStringify(key: string) {\n  return KEY_RE.test(key) ? key : JSON.stringify(key)\n}\n\nfunction getIndent(level: number) {\n  return ' '.repeat(2 * level)\n}\n"],
  "mappings": "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",
  "names": ["value", "ch"]
}
