{
  "version": 3,
  "sources": ["../src/parse.ts", "../src/stringify.ts", "../src/maml.ts"],
  "sourcesContent": ["const ESCAPE_MAP: Record<string, string> = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t',\n}\n\nexport function parse(source: string): any {\n  if (typeof source !== 'string') throw TypeError('Source must be a string')\n\n  let pos = 0,\n    lineNumber = 1,\n    ch: string,\n    done = false\n\n  next()\n  const value = parseValue()\n  skipWhitespace()\n\n  if (!done) {\n    throw new SyntaxError(errorSnippet())\n  }\n\n  expectValue(value)\n  return value\n\n  function next() {\n    if (pos < source.length) {\n      ch = source[pos]\n      pos++\n    } else {\n      ch = ''\n      done = true\n    }\n    if (ch === '\\n') {\n      lineNumber++\n    }\n  }\n\n  function lookahead2() {\n    return source.substring(pos, pos + 2)\n  }\n\n  function parseValue(): any {\n    skipWhitespace()\n    return (\n      parseMultilineString() ??\n      parseString() ??\n      parseNumber() ??\n      parseObject() ??\n      parseArray() ??\n      parseKeyword('true', true) ??\n      parseKeyword('false', false) ??\n      parseKeyword('null', null)\n    )\n  }\n\n  function parseString() {\n    if (ch !== '\"') return\n    let str = ''\n    let escaped = false\n    while (true) {\n      next()\n      if (escaped) {\n        if ((ch as string) === 'u') {\n          let unicode = ''\n          for (let i = 0; i < 4; i++) {\n            next()\n            if (!isHexDigit(ch)) {\n              throw new SyntaxError(\n                errorSnippet(`Invalid Unicode escape sequence`),\n              )\n            }\n            unicode += ch\n          }\n          str += String.fromCharCode(parseInt(unicode, 16))\n        } else {\n          const escapedChar = ESCAPE_MAP[ch]\n          if (!escapedChar) {\n            throw new SyntaxError(\n              errorSnippet(`Invalid escape sequence ${JSON.stringify(ch)}`),\n            )\n          }\n          str += escapedChar\n        }\n        escaped = false\n      } else if ((ch as string) === '\\\\') {\n        escaped = true\n      } else if (ch === '\"') {\n        break\n      } else if ((ch as string) === '\\n') {\n        throw new SyntaxError(\n          errorSnippet(\n            `Use \"\"\" for multiline strings or escape newlines with \"\\\\n\"`,\n          ),\n        )\n      } else if ((ch as string) < '\\x1F') {\n        throw new SyntaxError(\n          errorSnippet(`Unescaped control character ${JSON.stringify(ch)}`),\n        )\n      } else {\n        str += ch\n      }\n    }\n    next()\n    return str\n  }\n\n  function parseMultilineString() {\n    if (ch !== '\"' || lookahead2() !== '\"\"') return\n    next()\n    next()\n    next()\n    let hasLeadingNewline = false\n    if ((ch as string) === '\\n') {\n      hasLeadingNewline = true\n      next()\n    }\n\n    let str = ''\n    while (!done) {\n      if (ch === '\"' && lookahead2() === '\"\"') {\n        next()\n        next()\n        next()\n        if (str === '' && !hasLeadingNewline) {\n          throw new SyntaxError(\n            errorSnippet('Multiline strings cannot be empty'),\n          )\n        }\n        return str\n      }\n      str += ch\n      next()\n    }\n    throw new SyntaxError(errorSnippet())\n  }\n\n  function parseNumber() {\n    if (!isDigit(ch) && ch !== '-') return\n    let numStr = ''\n    let float = false\n    if (ch === '-') {\n      numStr += ch\n      next()\n      if (!isDigit(ch)) {\n        throw new SyntaxError(errorSnippet())\n      }\n    }\n    if (ch === '0') {\n      numStr += ch\n      next()\n    } else {\n      while (isDigit(ch)) {\n        numStr += ch\n        next()\n      }\n    }\n    if (ch === '.') {\n      float = true\n      numStr += ch\n      next()\n      if (!isDigit(ch)) {\n        throw new SyntaxError(errorSnippet())\n      }\n      while (isDigit(ch)) {\n        numStr += ch\n        next()\n      }\n    }\n    if (ch === 'e' || ch === 'E') {\n      float = true\n      numStr += ch\n      next()\n      if ((ch as string) === '+' || (ch as string) === '-') {\n        numStr += ch\n        next()\n      }\n      if (!isDigit(ch)) {\n        throw new SyntaxError(errorSnippet())\n      }\n      while (isDigit(ch)) {\n        numStr += ch\n        next()\n      }\n    }\n    return float ? parseFloat(numStr) : toSafeNumber(numStr)\n  }\n\n  function parseObject() {\n    if (ch !== '{') return\n    next()\n    skipWhitespace()\n    const obj: Record<string, any> = {}\n    if ((ch as string) === '}') {\n      next()\n      return obj\n    }\n    while (true) {\n      let key: string\n      if ((ch as string) === '\"') {\n        key = parseString()!\n      } else {\n        key = parseKey()\n      }\n\n      skipWhitespace()\n      if ((ch as string) !== ':') {\n        throw new SyntaxError(errorSnippet())\n      }\n      next()\n      const value = parseValue()\n      expectValue(value)\n      obj[key] = value\n      const newlineAfterValue = skipWhitespace()\n      if ((ch as string) === '}') {\n        next()\n        return obj\n      } else if ((ch as string) === ',') {\n        next()\n        skipWhitespace()\n        if ((ch as string) === '}') {\n          next()\n          return obj\n        }\n      } else if (newlineAfterValue) {\n        continue\n      } else {\n        throw new SyntaxError(\n          errorSnippet('Expected comma or newline between key-value pairs'),\n        )\n      }\n    }\n  }\n\n  function parseKey() {\n    let identifier = ''\n    while (isKeyChar(ch)) {\n      identifier += ch\n      next()\n    }\n    if (identifier === '') {\n      throw new SyntaxError(errorSnippet())\n    }\n    return identifier\n  }\n\n  function parseArray() {\n    if (ch !== '[') return\n    next()\n    skipWhitespace()\n    const array: any[] = []\n    if ((ch as string) === ']') {\n      next()\n      return array\n    }\n    while (true) {\n      const value = parseValue()\n      expectValue(value)\n      array.push(value)\n      const newLineAfterValue = skipWhitespace()\n      if ((ch as string) === ']') {\n        next()\n        return array\n      } else if ((ch as string) === ',') {\n        next()\n        skipWhitespace()\n        if ((ch as string) === ']') {\n          next()\n          return array\n        }\n      } else if (newLineAfterValue) {\n        continue\n      } else {\n        throw new SyntaxError(\n          errorSnippet('Expected comma or newline between values'),\n        )\n      }\n    }\n  }\n\n  function parseKeyword<T>(name: string, value: T) {\n    if (ch !== name[0]) return\n    for (let i = 1; i < name.length; i++) {\n      next()\n      if (ch !== name[i]) {\n        throw new SyntaxError(errorSnippet())\n      }\n    }\n    next()\n    if (\n      isWhitespace(ch) ||\n      ch === ',' ||\n      ch === '}' ||\n      ch === ']' ||\n      ch === undefined\n    ) {\n      return value\n    }\n    throw new SyntaxError(errorSnippet())\n  }\n\n  function skipWhitespace(): boolean {\n    let hasNewline = false\n    while (isWhitespace(ch)) {\n      hasNewline ||= ch === '\\n'\n      next()\n    }\n    const hasNewlineAfterComment = skipComment()\n    return hasNewline || hasNewlineAfterComment\n  }\n\n  function skipComment(): boolean {\n    if (ch === '#') {\n      while (!done && (ch as string) !== '\\n') {\n        next()\n      }\n      return skipWhitespace()\n    }\n    return false\n  }\n\n  function isWhitespace(ch: string) {\n    return ch === ' ' || ch === '\\n' || ch === '\\t' || ch === '\\r'\n  }\n\n  function isHexDigit(ch: string) {\n    return (ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'F')\n  }\n\n  function isDigit(ch: string) {\n    return ch >= '0' && ch <= '9'\n  }\n\n  function isKeyChar(ch: string) {\n    return (\n      (ch >= 'A' && ch <= 'Z') ||\n      (ch >= 'a' && ch <= 'z') ||\n      (ch >= '0' && ch <= '9') ||\n      ch === '_' ||\n      ch === '-'\n    )\n  }\n\n  function toSafeNumber(str: string) {\n    if (str == '-0') return -0\n    const num = Number(str)\n    return num >= Number.MIN_SAFE_INTEGER && num <= Number.MAX_SAFE_INTEGER\n      ? num\n      : BigInt(str)\n  }\n\n  function expectValue(value: unknown) {\n    if (value === undefined) {\n      throw new SyntaxError(errorSnippet())\n    }\n  }\n\n  function errorSnippet(\n    message = `Unexpected character ${JSON.stringify(ch)}`,\n  ) {\n    if (!ch) message = 'Unexpected end of input'\n    const lines = source.substring(pos - 40, pos).split('\\n')\n    let lastLine = lines.at(-1) || ''\n    let postfix =\n      source\n        .substring(pos, pos + 40)\n        .split('\\n', 1)\n        .at(0) || ''\n    if (lastLine === '') {\n      // error at \"\\n\"\n      lastLine = lines.at(-2) || ''\n      lastLine += ' '\n      lineNumber--\n      postfix = ''\n    }\n    const snippet = `    ${lastLine}${postfix}\\n`\n    const pointer = `    ${'.'.repeat(Math.max(0, lastLine.length - 1))}^\\n`\n    return `${message} on line ${lineNumber}.\\n\\n${snippet}${pointer}`\n  }\n}\n", "export function stringify(value: any): string {\n  return doStringify(value, 0)\n}\n\nfunction doStringify(value: any, level: number): string {\n  const kind =\n    value === null ? 'null' : Array.isArray(value) ? 'array' : typeof value\n\n  switch (kind) {\n    case 'string':\n      return JSON.stringify(value)\n\n    case 'boolean':\n    case 'bigint':\n    case 'number':\n      return `${value}`\n\n    case 'null':\n    case 'undefined':\n      return 'null'\n\n    case 'array': {\n      const len = value.length\n      if (len === 0) return '[]'\n\n      const childIndent = getIndent(level + 1)\n      const parentIndent = getIndent(level)\n      let out = '[\\n'\n      for (let i = 0; i < len; i++) {\n        if (i > 0) out += '\\n'\n        out += childIndent + doStringify(value[i], level + 1)\n      }\n      return out + '\\n' + parentIndent + ']'\n    }\n\n    case 'object': {\n      const keys = Object.keys(value)\n      const len = keys.length\n      if (len === 0) return '{}'\n\n      const childIndent = getIndent(level + 1)\n      const parentIndent = getIndent(level)\n      let out = '{\\n'\n      for (let i = 0; i < len; i++) {\n        if (i > 0) out += '\\n'\n        const key = keys[i]\n        out +=\n          childIndent +\n          doKeyStringify(key) +\n          ': ' +\n          doStringify(value[key], level + 1)\n      }\n      return out + '\\n' + parentIndent + '}'\n    }\n\n    default:\n      throw new Error(`Unsupported value type: ${kind}`)\n  }\n}\n\nconst KEY_RE = /^[A-Za-z0-9_-]+$/\nfunction doKeyStringify(key: string) {\n  return KEY_RE.test(key) ? key : JSON.stringify(key)\n}\n\nfunction getIndent(level: number) {\n  return ' '.repeat(2 * level)\n}\n", "import { parse, stringify } from './index.js'\n\nconst getGlobal = function() {\n  if (typeof globalThis !== 'undefined') return globalThis\n  if (typeof window !== 'undefined') return window\n  // @ts-ignore\n  if (typeof global !== 'undefined') return global\n  return Function('return this')()\n}\n\ngetGlobal().MAML = { parse, stringify }\n"],
  "mappings": "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",
  "names": ["ESCAPE_MAP", "parse", "source", "pos", "lineNumber", "ch", "done", "next", "value", "parseValue", "skipWhitespace", "errorSnippet", "expectValue", "lookahead2", "_a", "_b", "_c", "_d", "_e", "_f", "_g", "parseMultilineString", "parseString", "parseNumber", "parseObject", "parseArray", "parseKeyword", "str", "escaped", "unicode", "i", "isHexDigit", "escapedChar", "hasLeadingNewline", "isDigit", "numStr", "float", "toSafeNumber", "obj", "key", "parseKey", "newlineAfterValue", "identifier", "isKeyChar", "array", "newLineAfterValue", "name", "isWhitespace", "hasNewline", "hasNewlineAfterComment", "skipComment", "num", "message", "lines", "lastLine", "postfix", "snippet", "pointer", "stringify", "value", "doStringify", "level", "kind", "len", "childIndent", "getIndent", "parentIndent", "out", "i", "keys", "key", "doKeyStringify", "KEY_RE", "getGlobal", "parse", "stringify"]
}
