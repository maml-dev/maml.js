{
  "version": 3,
  "sources": ["../src/parse.ts", "../src/stringify.ts", "../src/maml.ts"],
  "sourcesContent": ["export function parse(source: string): any {\n  if (typeof source !== 'string') throw TypeError('Source must be a string')\n\n  let pos = 0,\n    lineNumber = 1,\n    ch: string,\n    done = false\n\n  next()\n  const value = parseValue()\n  skipWhitespace()\n\n  if (!done) {\n    throw new SyntaxError(errorSnippet())\n  }\n\n  expectValue(value)\n  return value\n\n  function next() {\n    if (pos < source.length) {\n      ch = source[pos]\n      pos++\n    } else {\n      ch = ''\n      done = true\n    }\n    if (ch === '\\n') {\n      lineNumber++\n    }\n  }\n\n  function lookahead2() {\n    return source.substring(pos, pos + 2)\n  }\n\n  function parseValue(): any {\n    skipWhitespace()\n    return (\n      parseMultilineString() ??\n      parseString() ??\n      parseNumber() ??\n      parseObject() ??\n      parseArray() ??\n      parseKeyword('true', true) ??\n      parseKeyword('false', false) ??\n      parseKeyword('null', null)\n    )\n  }\n\n  function parseString() {\n    if (ch !== '\"') return\n    let str = ''\n    let escaped = false\n    while (true) {\n      next()\n      if (escaped) {\n        if ((ch as string) === 'u') {\n          next()\n          if ((ch as string) !== '{') {\n            throw new SyntaxError(\n              errorSnippet(\n                errorMap.u + ' ' + JSON.stringify(ch) + ' (expected \"{\")',\n              ),\n            )\n          }\n          let hex = ''\n          while (true) {\n            next()\n            if ((ch as string) === '}') break\n            if (!isHexDigit(ch)) {\n              throw new SyntaxError(\n                errorSnippet(errorMap.u + ' ' + JSON.stringify(ch)),\n              )\n            }\n            hex += ch\n            if (hex.length > 6) {\n              throw new SyntaxError(\n                errorSnippet(errorMap.u + ' (too many hex digits)'),\n              )\n            }\n          }\n          if (hex.length === 0) {\n            throw new SyntaxError(errorSnippet(errorMap.u))\n          }\n          const codePoint = parseInt(hex, 16)\n          if (codePoint > 0x10ffff) {\n            throw new SyntaxError(errorSnippet(errorMap.u + ' (out of range)'))\n          }\n          str += String.fromCodePoint(codePoint)\n        } else {\n          const escapedChar = escapeMap[ch]\n          if (!escapedChar) {\n            throw new SyntaxError(\n              errorSnippet(errorMap.u + ' ' + JSON.stringify(ch)),\n            )\n          }\n          str += escapedChar\n        }\n        escaped = false\n      } else if ((ch as string) === '\\\\') {\n        escaped = true\n      } else if (ch === '\"') {\n        break\n      } else if ((ch as string) === '\\n') {\n        throw new SyntaxError(\n          errorSnippet(\n            `Use \"\"\" for multiline strings or escape newlines with \"\\\\n\"`,\n          ),\n        )\n      } else if ((ch as string) < '\\x1F') {\n        throw new SyntaxError(\n          errorSnippet(`Unescaped control character ${JSON.stringify(ch)}`),\n        )\n      } else {\n        str += ch\n      }\n    }\n    next()\n    return str\n  }\n\n  function parseMultilineString() {\n    if (ch !== '\"' || lookahead2() !== '\"\"') return\n    next()\n    next()\n    next()\n    let hasLeadingNewline = false\n    if ((ch as string) === '\\n') {\n      hasLeadingNewline = true\n      next()\n    }\n\n    let str = ''\n    while (!done) {\n      if (ch === '\"' && lookahead2() === '\"\"') {\n        next()\n        next()\n        next()\n        if (str === '' && !hasLeadingNewline) {\n          throw new SyntaxError(\n            errorSnippet('Multiline strings cannot be empty'),\n          )\n        }\n        return str\n      }\n      str += ch\n      next()\n    }\n    throw new SyntaxError(errorSnippet())\n  }\n\n  function parseNumber() {\n    if (!isDigit(ch) && ch !== '-') return\n    let numStr = ''\n    let float = false\n    if (ch === '-') {\n      numStr += ch\n      next()\n      if (!isDigit(ch)) {\n        throw new SyntaxError(errorSnippet())\n      }\n    }\n    if (ch === '0') {\n      numStr += ch\n      next()\n    } else {\n      while (isDigit(ch)) {\n        numStr += ch\n        next()\n      }\n    }\n    if (ch === '.') {\n      float = true\n      numStr += ch\n      next()\n      if (!isDigit(ch)) {\n        throw new SyntaxError(errorSnippet())\n      }\n      while (isDigit(ch)) {\n        numStr += ch\n        next()\n      }\n    }\n    if (ch === 'e' || ch === 'E') {\n      float = true\n      numStr += ch\n      next()\n      if ((ch as string) === '+' || (ch as string) === '-') {\n        numStr += ch\n        next()\n      }\n      if (!isDigit(ch)) {\n        throw new SyntaxError(errorSnippet())\n      }\n      while (isDigit(ch)) {\n        numStr += ch\n        next()\n      }\n    }\n    return float ? parseFloat(numStr) : toSafeNumber(numStr)\n  }\n\n  function parseObject() {\n    if (ch !== '{') return\n    next()\n    skipWhitespace()\n    const obj: Record<string, any> = {}\n    if ((ch as string) === '}') {\n      next()\n      return obj\n    }\n    while (true) {\n      const keyPos = pos\n      let key: string\n      if ((ch as string) === '\"') {\n        key = parseString()!\n      } else {\n        key = parseKey()\n      }\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        pos = keyPos\n        throw new SyntaxError(\n          errorSnippet(`Duplicate key ${JSON.stringify(key)}`),\n        )\n      }\n      skipWhitespace()\n      if ((ch as string) !== ':') {\n        throw new SyntaxError(errorSnippet())\n      }\n      next()\n      const value = parseValue()\n      expectValue(value)\n      obj[key] = value\n      const newlineAfterValue = skipWhitespace()\n      if ((ch as string) === '}') {\n        next()\n        return obj\n      } else if ((ch as string) === ',') {\n        next()\n        skipWhitespace()\n        if ((ch as string) === '}') {\n          next()\n          return obj\n        }\n      } else if (newlineAfterValue) {\n        continue\n      } else {\n        throw new SyntaxError(\n          errorSnippet('Expected comma or newline between key-value pairs'),\n        )\n      }\n    }\n  }\n\n  function parseKey() {\n    let identifier = ''\n    while (isKeyChar(ch)) {\n      identifier += ch\n      next()\n    }\n    if (identifier === '') {\n      throw new SyntaxError(errorSnippet())\n    }\n    return identifier\n  }\n\n  function parseArray() {\n    if (ch !== '[') return\n    next()\n    skipWhitespace()\n    const array: any[] = []\n    if ((ch as string) === ']') {\n      next()\n      return array\n    }\n    while (true) {\n      const value = parseValue()\n      expectValue(value)\n      array.push(value)\n      const newLineAfterValue = skipWhitespace()\n      if ((ch as string) === ']') {\n        next()\n        return array\n      } else if ((ch as string) === ',') {\n        next()\n        skipWhitespace()\n        if ((ch as string) === ']') {\n          next()\n          return array\n        }\n      } else if (newLineAfterValue) {\n        continue\n      } else {\n        throw new SyntaxError(\n          errorSnippet('Expected comma or newline between values'),\n        )\n      }\n    }\n  }\n\n  function parseKeyword<T>(name: string, value: T) {\n    if (ch !== name[0]) return\n    for (let i = 1; i < name.length; i++) {\n      next()\n      if (ch !== name[i]) {\n        throw new SyntaxError(errorSnippet())\n      }\n    }\n    next()\n    if (\n      isWhitespace(ch) ||\n      ch === ',' ||\n      ch === '}' ||\n      ch === ']' ||\n      ch === undefined\n    ) {\n      return value\n    }\n    throw new SyntaxError(errorSnippet())\n  }\n\n  function skipWhitespace(): boolean {\n    let hasNewline = false\n    while (isWhitespace(ch)) {\n      hasNewline ||= ch === '\\n'\n      next()\n    }\n    const hasNewlineAfterComment = skipComment()\n    return hasNewline || hasNewlineAfterComment\n  }\n\n  function skipComment(): boolean {\n    if (ch === '#') {\n      while (!done && (ch as string) !== '\\n') {\n        next()\n      }\n      return skipWhitespace()\n    }\n    return false\n  }\n\n  function isWhitespace(ch: string) {\n    return ch === ' ' || ch === '\\n' || ch === '\\t' || ch === '\\r'\n  }\n\n  function isHexDigit(ch: string) {\n    return (ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'F')\n  }\n\n  function isDigit(ch: string) {\n    return ch >= '0' && ch <= '9'\n  }\n\n  function isKeyChar(ch: string) {\n    return (\n      (ch >= 'A' && ch <= 'Z') ||\n      (ch >= 'a' && ch <= 'z') ||\n      (ch >= '0' && ch <= '9') ||\n      ch === '_' ||\n      ch === '-'\n    )\n  }\n\n  function toSafeNumber(str: string) {\n    if (str == '-0') return -0\n    const num = Number(str)\n    return num >= Number.MIN_SAFE_INTEGER && num <= Number.MAX_SAFE_INTEGER\n      ? num\n      : BigInt(str)\n  }\n\n  function expectValue(value: unknown) {\n    if (value === undefined) {\n      throw new SyntaxError(errorSnippet())\n    }\n  }\n\n  function errorSnippet(\n    message = `Unexpected character ${JSON.stringify(ch)}`,\n  ) {\n    if (!ch) message = 'Unexpected end of input'\n    const lines = source.substring(pos - 40, pos).split('\\n')\n    let lastLine = lines.at(-1) || ''\n    let postfix =\n      source\n        .substring(pos, pos + 40)\n        .split('\\n', 1)\n        .at(0) || ''\n    if (lastLine === '') {\n      // error at \"\\n\"\n      lastLine = lines.at(-2) || ''\n      lastLine += ' '\n      lineNumber--\n      postfix = ''\n    }\n    const snippet = `    ${lastLine}${postfix}\\n`\n    const pointer = `    ${'.'.repeat(Math.max(0, lastLine.length - 1))}^\\n`\n    return `${message} on line ${lineNumber}.\\n\\n${snippet}${pointer}`\n  }\n}\n\nconst escapeMap: Record<string, string> = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t',\n}\n\nconst errorMap = {\n  u: 'Invalid escape sequence',\n}\n", "export function stringify(value: any): string {\n  return doStringify(value, 0)\n}\n\nfunction doStringify(value: any, level: number): string {\n  const kind =\n    value === null ? 'null' : Array.isArray(value) ? 'array' : typeof value\n\n  switch (kind) {\n    case 'string':\n      return JSON.stringify(value)\n\n    case 'boolean':\n    case 'bigint':\n    case 'number':\n      return `${value}`\n\n    case 'null':\n    case 'undefined':\n      return 'null'\n\n    case 'array': {\n      const len = value.length\n      if (len === 0) return '[]'\n\n      const childIndent = getIndent(level + 1)\n      const parentIndent = getIndent(level)\n      let out = '[\\n'\n      for (let i = 0; i < len; i++) {\n        if (i > 0) out += '\\n'\n        out += childIndent + doStringify(value[i], level + 1)\n      }\n      return out + '\\n' + parentIndent + ']'\n    }\n\n    case 'object': {\n      const keys = Object.keys(value)\n      const len = keys.length\n      if (len === 0) return '{}'\n\n      const childIndent = getIndent(level + 1)\n      const parentIndent = getIndent(level)\n      let out = '{\\n'\n      for (let i = 0; i < len; i++) {\n        if (i > 0) out += '\\n'\n        const key = keys[i]\n        out +=\n          childIndent +\n          doKeyStringify(key) +\n          ': ' +\n          doStringify(value[key], level + 1)\n      }\n      return out + '\\n' + parentIndent + '}'\n    }\n\n    default:\n      throw new Error(`Unsupported value type: ${kind}`)\n  }\n}\n\nconst KEY_RE = /^[A-Za-z0-9_-]+$/\nfunction doKeyStringify(key: string) {\n  return KEY_RE.test(key) ? key : JSON.stringify(key)\n}\n\nfunction getIndent(level: number) {\n  return ' '.repeat(2 * level)\n}\n", "import { parse, stringify } from './index.js'\n\n/* v8 ignore next 7 */\nconst getGlobal = function () {\n  if (typeof globalThis !== 'undefined') return globalThis\n  if (typeof window !== 'undefined') return window\n  // @ts-ignore\n  if (typeof global !== 'undefined') return global\n  return Function('return this')()\n}\n\ngetGlobal().MAML = { parse, stringify }\n"],
  "mappings": "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",
  "names": ["parse", "source", "pos", "lineNumber", "ch", "done", "next", "value", "parseValue", "skipWhitespace", "errorSnippet", "expectValue", "lookahead2", "_a", "_b", "_c", "_d", "_e", "_f", "_g", "parseMultilineString", "parseString", "parseNumber", "parseObject", "parseArray", "parseKeyword", "str", "escaped", "errorMap", "hex", "isHexDigit", "codePoint", "escapedChar", "escapeMap", "hasLeadingNewline", "isDigit", "numStr", "float", "toSafeNumber", "obj", "keyPos", "key", "parseKey", "newlineAfterValue", "identifier", "isKeyChar", "array", "newLineAfterValue", "name", "isWhitespace", "hasNewline", "hasNewlineAfterComment", "skipComment", "num", "message", "lines", "lastLine", "postfix", "snippet", "pointer", "stringify", "value", "doStringify", "level", "kind", "len", "childIndent", "getIndent", "parentIndent", "out", "i", "keys", "key", "doKeyStringify", "KEY_RE", "getGlobal", "parse", "stringify"]
}
